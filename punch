#!/usr/bin/en/env python
import asyncore, socket
import logging
from cStringIO import StringIO
from urlparse import urlparse
import sys
import time as T

def isHeader(string): ##
    return "\r\n\r\n" in string

def mysend(sock, msg):
    totalsent = 0
    while totalsent < len(msg):

        sent = sock.send(msg[totalsent:])
        if sent == 0:
            raise RuntimeError("socket connection broken")
        totalsent = totalsent + sent

def myreceive(msgsize, s, c): ##
    # print "In myrecv"
    # print "msgsize: "+str(msgsize)
    bytes_recd = 0
    s.settimeout(12)
    while bytes_recd < msgsize:
        chunk = s.recv(min(msgsize - bytes_recd, 4096))
        if chunk == '':
            break
        bytes_recd = bytes_recd + len(chunk)
    if c==1:
        if (msgsize==bytes_recd):
            global GoodCount
            GoodCount+=1
        else:
            global BadCount
            BadCount+=1


def make_request(req_type, what, details, ver="1.1"):
    NL = "\r\n"
    req_line = "{verb} {w} HTTP/{v}".format(
        verb=req_type, w=what, v=ver
    )
    details = [
        "{name}: {v}".format(name=n, v=v) for (n, v) in details.iteritems()
        ]
    detail_lines = NL.join(details)
    full_request = "".join([req_line, NL, detail_lines, NL, NL])
    return full_request


def parse_url(url, DEFAULT_PORT=80):
    parsed_url = urlparse(url)
    host, path, port = (parsed_url.hostname,
                        parsed_url.path,
                        parsed_url.port)
    if not port:
        port = DEFAULT_PORT
    return (host, path, port)


# HTTPClient inherits from asyncore.dispatcher
class HTTPClient(asyncore.dispatcher):
    ## Size of the buffer for each recv
    RECV_CHUNK_SIZE = 8192

    def __init__(self, request, host, port, path):
        asyncore.dispatcher.__init__(self)
        self.request = request
        self.host, self.port, self.path = host, port, path
        self.countread = 0


        self.headDictionary={}
        getContentLen=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        getContentLen.connect((self.host, self.port))
        mysend(getContentLen, make_request('GET', path,
                       {'Host': host,
                        'Connection': 'close',
                        "P2Tag": "u5480574_u5780978"}
                       ))
        header=""
        prev_data=""
        while True:
            data_received = getContentLen.recv(4096)
            if isHeader(data_received) == True or isHeader(
                            prev_data[len(prev_data) - 3:] + data_received[0:3]) == True:
                header = header + data_received
                # print "head found"
                allHead, Body = header.split("\r\n\r\n")
                headerLst = allHead.split("\r\n")
                for info in headerLst[1:]:
                    field, value = info.split(": ")
                    self.headDictionary[field] = value
                getContentLen.close()
                break
            else:
                header = header + data_received
                prev_data = data_received
        self.contentLen=long(self.headDictionary["Content-Length"])
        self.Body=""
        self.previousData=""

        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect((host, port))
        (self.recvbuf, self.sendbuf) = (StringIO(), "")
        self.starttime = T.time()
        self.write(self.request)

    def write(self, data):
        self.Body = ""
        self.previousData = ""
        self.countread = 0

        """ Schedule to deliver data over the socket """

        self.sendbuf += data

    def handle_connect(self):
        pass

    def handle_close(self):
        # print "enter handle_close ----->>>> count so far: "+str(GoodCount+BadCount)

        # sys.exit()
        self.close()

    def writable(self):
        # print 'writeable'
        return len(self.sendbuf) > 0

    def handle_write(self):
        # print 'hwrite'
        bytes_sent = self.send(self.sendbuf)
        self.sendbuf = self.sendbuf[bytes_sent:]

    def handle_read(self):

        data_received = self.recv(HTTPClient.RECV_CHUNK_SIZE)
        global timeLst
        if isHeader(data_received) == True or isHeader(
                        self.previousData[len(self.previousData) - 3:] + data_received[0:3]) == True:
            self.Body = self.Body + data_received
            # print "head found"
            # print self.Body
            allHead, self.Body = self.Body.split("\r\n\r\n")
            if "HTTP/1.1 200" not in allHead:
                # print "enter bad count"
                timeLst += [(T.time() - self.starttime) * 1000]
                global BadCount
                BadCount+=1
                self.countread=1
            # print self.Body
        else:
            self.Body = self.Body + data_received
            self.previousData = data_received
        if len(self.Body)==self.contentLen:
            if self.countread==0:
                timeLst += [(T.time() - self.starttime)*1000]
                global GoodCount
                GoodCount+=1
                self.countread=1
            if GoodCount + BadCount > NumReq - concurrent*2 and GoodCount + BadCount < NumReq:
                # print "make close:    count so far: " + str(GoodCount + BadCount)
                self.request = make_request('GET', self.path,
                                            {'Host': self.host,
                                             'Connection': 'close',
                                             "P2Tag": "u5480574_u5780978"}
                                            )
                # print self.request
                data_received = ""
                self.sendbuf = ""
                self.write(self.request)
            else:
                data_received = ""
                self.sendbuf = ""
                self.write(self.request)


    def getSocket(self):
        return self.socket.fileno()


def AmountOfConcurrentRequests(maxConc, request, host, port, path):
    dic = {}
    count = 0
    lst = []

    for i in range(maxConc):
        obj = HTTPClient(request, host, port, path)
        dic[obj.getSocket()] = obj
    # global dic
    return dic


NumReq = int(sys.argv[2])
concurrent = int(sys.argv[4])
url = sys.argv[5]
GoodCount = 0
BadCount = 0
timeLst = []
# print NumReq
# print concurrent
# print url

start = T.time()


host, path, port = parse_url(url)
request = make_request('GET', path,
                       {'Host': host,
                        'Connection': 'keep-alive',
                        "P2Tag": "u5480574_u5780978"}
                       )

global dic2
if concurrent>=NumReq:
    dic2=AmountOfConcurrentRequests(NumReq, make_request('GET', path,{'Host': host,'Connection': 'close', "P2Tag": "u5480574_u5780978"}), host, port, path)
else:
    dic2 = AmountOfConcurrentRequests(concurrent, request, host, port, path)

if __name__ == "__main__":
    asyncore.loop()
    # global dic2
    # global Gcount
    # global NumReq
    # global BadCount
    # global GoodCount
    totalTime = T.time() - start
    timeLst.sort()
    index = len(timeLst) - 1
    print 'Time Take for requests: ' + str(totalTime) + " s"
    print 'Completed requests: ' + str(GoodCount)
    print 'Failed requests: ' + str(BadCount)
    print 'Avg requests per second: ' + str(GoodCount / totalTime) + " req/s"
    print
    print "Percentage of the requests served within a certain time"
    print "50% "+str(timeLst[int(index*0.5)])
    print "60% " + str(timeLst[int(index * 0.6)])
    print "70% " + str(timeLst[int(index * 0.7)])
    print "80% " + str(timeLst[int(index * 0.8)])
    print "90% " + str(timeLst[int(index * 0.9)])
    print "100% " + str(timeLst[int(index )])
